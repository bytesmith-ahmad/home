#!/bin/bash

# accidental duplicates, refactor before removing
archives=$HOME/arch
parent_dir="$HOME/arch"

# Function to display usage instructions
function display_usage() {
    echo "Usage: $0 [options] [patterns]"
    echo "Options:"
    echo "  --help     Display this help message"
    echo "  -a         Show hidden files"
    echo "  -s         Display file sizes"
    echo "  -L <level> Limit the depth of the directory tree"
    echo "Patterns:"
    echo "  Specify search patterns to filter directory names"
}

# search flag
search=0

# Check if the user provided the --help option ************************************************
if [[ "$1" == "--help" ]]; then
    display_usage
    exit 0
fi

# [select] ************************************************************************************

if [ $# -eq 0 ]; then
    echo "Consider adding limit config"
    tree $archives
    exit 0
fi

# [Select + filter] Construct the pattern string by joining the arguments with | **************

pattern=""
for arg in "$@"; do
    if [ -z "$pattern" ]; then
        pattern="*$arg*"
    else
        pattern="$pattern|*$arg*"
    fi
    search=1
done

# [create] ($EDITOR $path) ********************************************************************

# not implemented

# [update] If the first argument is 'edit', edit documents in ~/arch **************************
if [[ "$1" == "edit" ]]; then
    # Use eval to expand wildcard pattern in $2
    files=$(eval "ls -d $HOME/arch/$2")
    
    # Check if any files match the pattern
    if [ -n "$files" ]; then
        # Iterate over the matched files and edit them with the $EDITOR
        for file in $files; do
            $EDITOR "$file"
        done
        exit $?
    else
        echo -e "\e[31mNo matching files found.\e[0m"
        exit 1
    fi
fi

# [delete] (rm or rmdir) **********************************************************************

# not implemented

# Anything that doesn't fit above operations can be executed using 'sh' ***********************

# If the first argument is 'sh', execute shell commands inside ~/arch
if [[ "$1" == "sh" ]]; then
    # Get the rest of the arguments as shell commands
    shift
    # Change directory to ~/arch and execute the provided shell commands
    (cd "$archives" && eval "$@")
    exit $?
fi

# shortcut bypassing 'sh'

# Check if the first argument is a valid command
if command -v "$1" &>/dev/null; then
    # Change directory to the parent directory
    cd "$parent_dir" || exit 1

    # Execute the command with the provided arguments
    eval "$@"
    exit $?
else
    echo "Command '$1' not found"
    exit 1
fi

# Execute search if flag is raised ************************************************************

if [ "$search" -eq 1 ]; then
    # Search using tree command and only display output if found
    output=$(tree $archives -C --dirsfirst --prune --matchdirs -P "$pattern")
    # Check if the output contains any directories or files
    if [[ $output == *"0 directories, 0 files"* ]]; then
        exit 1
    else
        echo "$output"
        exit 0
    fi
else
    echo "No search pattern provided."
    exit 1
fi

# End of program ==============================================================================

#tree --prune arch -P 'iraqi*|car*'

### To implement in future:

# 1. Error Handling:
# Add checks to handle cases where the specified directory doesn't exist
# or where the 'tree' command is not available.

# 2. Custom Output:
# Allow users to specify options for the 'tree' command,
# such as showing hidden files (-a), displaying file sizes (-s),
# or limiting the depth of the directory tree (-L).

# 3. Interactive Mode:
# Implement an interactive mode where users can input search patterns
# one by one and see the results immediately.

# 4. Documentation:
# Include a help message (-h or --help) to explain how to use the script
# and what options are available.

# 5. Logging:
# Optionally, log the script's activity to a file for record-keeping
# or debugging purposes.

# 6. Configuration File:
# Allow users to specify search patterns and other options in a
# configuration file, making it easier to use the script with
# predefined settings.
